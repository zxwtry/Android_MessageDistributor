001 给定一个无序整型数组arr，找到数组中未出现的最小正整数。
    【举例】
        arr=[-1,2,3,4]  返回1
        arr=[1,2,3,4]   返回5
    【要求】
        时间O(N) 空间O(1)
    l   初始0，[1 --> l]上面的数都已经收集
    r   初始N，遍历到当前位置，在后续最优的情况下，可以遍历[1 --> r]
    位于arr[i]，实际遍历以l遍历
        int val = arr[i]
        如果val <= l
            r --;
        else if val > r
            r --;
        else if val == l+1
            l ++;
        else {
            if (arr(val-1) == val)
                r --;
            else
                swap(arr, i, val-1)
                回到判断
        }
002 数组排序之后相邻数的最大差值
    给定一个整型数组arr，返回如果排序之后，相邻两数的最大差值
    【举例】
        arr=[9,3,1,10]
        如果排序，结果是[1,3,9,10]，9和3的差为最大差值，故返回6
    【要求】
        如果arr的长度为N，时间复杂度O(N)，空间O(N)
   两个N的数组，用于记录最大值和最小值，没有的话-1         
003 数组小和
    定义：数组s=[1,3,5,2,4,6]
        s[0]的左边小于等于s[0]的数的和为0
        s[1]的左边小于等于s[1]的数的和为1
        s[2]的左边小于等于s[2]的数的和为1+3=4
        s[3]的左边小于等于s[3]的数的和为1
        s[4]的左边小于等于s[4]的数的和为1+3+2=6
        s[5]的左边小于等于s[5]的数的和为1+3+5+2+4=15
        所以s的小和=0+1+4+6+15=27
        给定一个数组s，返回s的小和
    归并思想 O(N*logN)
004 动态规划的空间优化方法
    给定一个矩阵m，从左上角开始每次只能像右或者向下走，最后到达右下角
    位置，路径上所有的数字累加起来就是路径和，返回最小的路径和。
    【举例】
        如果给定矩阵m如下
        1 3 5 9
        8 1 3 4
        5 0 6 1
        8 8 4 0
        路径1 3 1 0 6 1 0就是所有路径中路径和最小的，所以返回12
    【要求】
        如果矩阵大小M*N，时间复杂度O(M*N)，空间复杂度O(min{M,N})
	
005	未排序正数数组中累加和为给定值的最长子数组长度
	【题目】
	给定一个数组arr，该数组无序，但每个值均为正数，再给定一个正数k。求arr的所有子数组中所有元素相加和为k的最长子数组长度。
	例如，arr=[1,2,1,1,1]，k=3。
	累加和为3的最长子数组为[1,1,1]，所以结果返回3。
	【要求】
	时间复杂度O(N)，额外空间复杂度O(1)
	
006	未排序数组中累加和为给定值的最长子数组系列问题
	【题目】
	给定一个无序数组arr，其中元素可正、可负、可0，给定一个整数k。求arr所有的子数组中累加和为k的最长子数组长度。
	【补充题目】
	给定一个无序数组arr，其中元素可正、可负、可0。求arr所有的子数组中正数与负数个数相等的最长子数组长度。
	【补充题目】
	给定一个无序数组arr，其中元素只是1或0。求arr所有的子数组中0和1个数相等的最长子数组长度。
	【要求】
	时间复杂度O(N)
	
	
007	未排序数组中累加和小于或等于给定值的最长子数组长度
	【题目】
	给定一个无序数组arr，其中元素可正、可负、可0，给定一个整数k。求arr所有的子数组中累加和小于或等于k的最长子数组长度。
	例如：arr=[3,-2,-4,0,6]，k=-2，相加和小于或等于-2的最长子数组为{3,-2,-4,0}，所以结果返回4。
	【要求】
	时间复杂度(N*logN)
	

001 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词
    看到有人说堆排序，难道不应该是桶排序吗
002 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？
    看到有人说二分，能吗？
    无符号的数大概是从0-42亿，当然那40亿个数中可能有重复的。
    开512M内存，总共4G个（已经大于40亿）整数，每一个比特位表征一个整数。遍历这40亿的数据，按对应比特位初始化好这512M的内存。
003 给出一个从小到大排好序的整数数组nums和一个整数n，在数组中添加若干个补丁（元素）使得[1,n]的区间内的所有数都可以表示成nums中若干个数的和。返回最少需要添加的补丁个数。 Example， nums = [1, 3], n = 6 返回1，表示至少需要添加1个数｛2｝，才可以表示1到6之间所有数
004 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。

001 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，
    内存限制大小是1M。返回频数最高的100个词
    看到有人说堆排序，难道不应该是桶排序吗

002 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如
    何快速判断这个数是否在那40亿个数当中？
    看到有人说二分，能吗？
    无符号的数大概是从0-42亿，当然那40亿个数中可能有重复的。
    开512M内存，总共4G个（已经大于40亿）整数，每一个比特位表征一个整
    数。遍历这40亿的数据，按对应比特位初始化好这512M的内存。

003 给出一个从小到大排好序的整数数组nums和一个整数n，在数组中添加若干
    个补丁（元素）使得[1,n]的区间内的所有数都可以表示成nums中若干个数
    的和。返回最少需要添加的补丁个数。 Example， nums = [1, 3], n = 6
    返回1，表示至少需要添加1个数｛2｝，才可以表示1到6之间所有数

004 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每
    个文件的query都可能重复。要求你按照query的频度排序。

005 现在有A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是
    4G，找出A,B文件共同的URL，如果是三个乃至n个文件呢？
    在容许一定错误的情况下，试着使用Bloom Filter。4G=2^32=40亿=320bit
    n=50亿，按出错率0.01计算，需要1.44*lg(100)*50亿=480亿(这里lg以2为
    底)

006 给定一个随机数发生器，每次调用可等概率生成0,1之一。要求使用这个随
    机数发生器实现一个随机生成1-K之间数的随机数发生器。题很简单，代码
    在github/zxwtry/store/python/201607/P006_随机数发生器

007 给定m>0, e>0，计算如下程序
    void run(int m, int e) {
        int x = m;
        int y = 1;
        while (x - y > e) {
            x = (x + y) / 2;
            y = m / x;
        }
    }
    求run的复杂度。
    x的变化是 x, x/2, x/4, x/8, x/16, x/32, ...即总数log(m)
    y的变化是 1, 2, 4, 8, 16, 32, ...即总数log(m)
    大概在0.5*log(m)处，就执行完成了。
    故时间复杂度是：O(logm)

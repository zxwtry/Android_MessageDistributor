01	Flask简介
	1,	轻量级Web应用框架；
	2,	由Python编写；
	3,	基于WerkzengWSGI工具箱和Jinja2模板引擎；
	4,	没有默认使用的数据库，窗体验证工具；
	5,	使用Flask-extension加入这些功能：ORM，窗口验证工具，上传工具，开放式身份验证技术。
02	安装过程
	1,	virtualenv
		virtualenv允许多个不同版本的Python安装，每个服务于各自的项目。提供一种方式使环境独立。
	2,	sudo apt-get install python-virtualenv
	3,	创建一个单独的空文件夹，运行 virtualenv venv
	4,	现在只要想要在某个项目上工作，只要激活相应的环境
		. venv/bin/activate
	5,	激活virtualenv中的flask
		pip install -i http://mirrors.aliyun.com/pypi/simple flask
	6,	体验最新的Flask(Living on the Edge)
		两种方式：1，可以使用pip拉取开发版本；2，git checkout
		无论哪种方式，都推荐使用virtualenv
		a,	在一个新的virtualenv上获取一个git checkout，在开发模式下运行：
			git clone http://git.shiyanlou.com/shiyanlou/flask
			cd flask
			virtualenv venv --distribute
			. venv/bin/activate
			python setup.py develop
			这会拉取依赖关系并激活git head作为virtualenv中的当前版本。
			只需要执行git push origin来升级到最新版本
		b,	没有git下获取最新的开发版本，需要执行：
			mkdir flask
			cd flask
			virtualenv venv --distribute
			. venv/bin/activate
			pip install -i http://mirrors.aliyun.com/pypi/simple Flask==dev
03	最小的应用
	1,	见demo01_mini.py文件
		打开内部浏览器能够访问http://127.0.0.1:5000/
		但是通过win7（主机）不能够通过ip访问
	2,	代码的作用：
		a,	__name__	单一模块，第一个参数，应用模块的名称
		b,	route()告诉Flask哪个URL才能触发函数
		c,	if __name__ == '__main__'
		d,	可以对外服务app.run(host='0.0.0.0')
		e,	调试模式方法一
			app.debug = True
			app.run()
		f,	调试模式方法二
			app.run(debug=True)
		g,	尽管交互式调试器不能在分叉(forking)环境上工作(这使得它几乎不可能在生产服务器上使用)，它依然允许执行任意代码。这使它成为一个巨大的安全风险，绝对不能用于生产环境。
	3,	demo02_mini.py
		int 	整型
		float	浮点
		path	和默认的相似，但也接受斜线
	4,	url规范
		a,	@app.route('/aabbcc/')
		b,	@app.route('/ddeeff')
		c,	输入网址的时候，右边的'/'可少不可多
		d,	@app.route('/gghhii')和@app.route('gghhii/')是可以同时存在的
			但应该避免，原因：避免被搜索引擎索引同一个页面两次。
	5,	构建URL	demo03_mini.py的好处：
		a,	可描述，允许一次性修改URL
		b,	不用管特殊字符和Unicode转义
		c,	如果不在根目录，url_for()会自动处理好
	6,	HTTP demo04_http.py(有bug无法正常运行):
		a,	GET	
		b,	POST	一次
		c,	PUT		多次覆盖
		d,	HEAD	只要头，底层Werkzeug库会处理
04	静态文件
	1,	在有flask和venv文件夹的目录文件中，新建一个static文件夹，启动服务器之后
	，输入/static/***.html即可访问。
	2,	给静态文件生成URL，使用特殊的static端：
		url_for('static', filename='style.css')
		这个文件应该是static/style.css
	3,	如果app.route('string')的string中如果含有.的话，这个好像是不会被解析的。
	4,	如果static/aabbcc是一个文件的话，访问就是下载的意思，貌似最后多加一个'/'也是支持的。
05	渲染模板
	1,	Flask配置好Jinja模块，用于生成html文件。
	2,	可以使用方法render_template()来渲染模板。
	3,	在模板中可以使用request，session和g对象，也能使用函数get_flashed_messages()
	4,	需要学习模板继承，实现特定元素(如：标题，导航和页脚)在每一页成为可能
	5,	自动转义默认开启，如果name包含html，那么是会自动转义的。
	6,	如果信任一个变量，并且知道它是安全的(例如一个模块把wiki标记切换到HTML)，可以用Markup类或lsafe过滤器在模板中标记它是安全的。多看Jinja2文档。
06	如果是同一个链接@app.route('/main/') @app.route('/main/<name>') @app.route('/main')
	第3个是会出问题的。记住就好。
